import re
from typing import Tuple, List, Dict, Any, Set

class AutoFixer:
    def __init__(self, html_content: str):
        self.original_html = html_content
        self.current_html = html_content
        self.changes: List[Dict[str, Any]] = []
        self.manual_warnings: List[Dict[str, Any]] = []
        self._existing_ids: Set[str] = set(re.findall(r'id=["\']([^"\']+)["\']', html_content))

    def _get_line_number(self, index: int, content: str) -> int:
        return content.count('\n', 0, index) + 1

    def _log_change(self, rule_name: str, before: str, after: str, index: int):
        line_num = self._get_line_number(index, self.current_html)
        self.changes.append({
            "line": line_num,
            "rule": rule_name,
            "before": before.strip()[:60] + "...",
            "after": after.strip()[:60] + "..."
        })

    def _apply_regex(self, pattern: str, replacement: str, rule_name: str, conditional_check: bool = True):
        try:
            def replacer(match):
                before_text = match.group(0)
                try:
                    after_text = match.expand(replacement)
                except Exception:
                    after_text = replacement
                
                if conditional_check and before_text == after_text:
                    return before_text
                
                self._log_change(rule_name, before_text, after_text, match.start())
                return after_text

            self.current_html = re.sub(pattern, replacer, self.current_html, flags=re.IGNORECASE | re.DOTALL)
        except re.error as e:
            print(f"Error crítico en regla '{rule_name}': {e}")

    def _fix_head_metadata(self):
        if re.search(r'<html[^>]*lang=["\']es["\'][^>]*lang=["\']en["\']', self.current_html, re.I):
            self._apply_regex(r'<html[^>]*>', '<html lang="es-ES">', "Head: Unificar conflicto lang es/en")
        
        self._apply_regex(r'<meta charset="UTF-8">', '', "Head: Limpieza charset duplicado")
        self._apply_regex(r'<meta\s+charset=["\']?utf-?88?["\']?\s*/?>', '<meta charset="UTF-8">', "Head: Corrección charset malformado")
        self._apply_regex(r'<meta\s+http-equiv=["\']Content-Type["\']\s+content=["\']text/html;\s*charset=[^"\']+["\']\s*/?>', '<meta charset="UTF-8">', "Head: Modernizar meta http-equiv")
        
        if "charset" not in self.current_html.lower():
            self._apply_regex(r'(<head[^>]*>)', r'\1\n  <meta charset="UTF-8">', "Head: Inserción Charset faltante")

        self._apply_regex(r'<title>\s*</title>', '<title>Documento Accesible</title>', "Head: Title vacío rellenado")
        self._apply_regex(r'<title>(.*?)<title>', r'<title>\1</title>', "Head: Cierre title malformado")
        self._apply_regex(r'<title>(.*?)(?:<!--.*?-->)?</title>', r'<title>\1</title>', "Head: Limpieza comentarios en title")
        if "<title>" not in self.current_html.lower():
            self._apply_regex(r'(<head[^>]*>)', r'\1\n  <title>Documento Accesible</title>', "Head: Inserción Title faltante")

        if not re.search(r'<meta\s+name=["\']viewport["\']', self.current_html, re.I):
             self._apply_regex(r'(<head[^>]*>)', r'\1\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">', "Head: Inserción Viewport")
        
        self._apply_regex(r'content=["\']width=device-width\s+initial-scale=1(\.0)?["\']', 'content="width=device-width, initial-scale=1.0"', "Head: Sintaxis Viewport")
        self._apply_regex(r'(viewport[^>]*content=["\'][^"\']*)\b(?:user-scalable=no|maximum-scale=1\.0|maximum-scale=1)\b', r'\1user-scalable=yes', "Head: Desbloquear zoom usuario")

    def _fix_css_and_styles(self):
        self._apply_regex(r'outline:\s*none;?', 'outline: 3px solid #ff9900;\n      outline-offset: 2px;', "CSS: Restaurar foco visible")
        self._apply_regex(r'outline-offset:\s*2px;', 'outline-offset: 2px;', "CSS: Check outline-offset")
        self._apply_regex(r'display:\s*nonee;?', 'display: none;', "CSS: Typo display nonee")
        self._apply_regex(r'width:\s*1000%;', 'width: 100%;', "CSS: 1000% a 100%")
        self._apply_regex(r'background-color:\s*var\(--color-fond\)', 'background-color: var(--color-fondo)', "CSS: Typo variable fondo")
        self._apply_regex(r'"Segoe UI"\s+sans-serif', '"Segoe UI", sans-serif', "CSS: Coma faltante font-family")
        self._apply_regex(r'color:\s*#00000;', 'color: #000000;', "CSS: Hex incompleto")
        self._apply_regex(r'(--color-fondo: #[0-9a-fA-F]{6})(\s+--color)', r'\1;\2', "CSS: Punto y coma faltante")
        self._apply_regex(r'style=["\'][^"\']*display:\s*none[^"\']*["\']', 'hidden', "HTML: Style display none a atributo hidden")

    def _fix_structure_and_semantics(self):
        if "<main" not in self.current_html.lower():
            pattern = r'<div\s+([^>]*\b(role=["\']main["\']|id=["\'](?:main|content|contenido)["\'])[^>]*)>'
            def main_replacer(match):
                attrs = re.sub(r'role=["\']main["\']', '', match.group(1))
                return f'<main {attrs}>'
            self.current_html = re.sub(pattern, main_replacer, self.current_html, count=1, flags=re.I)
            if "<main" in self.current_html:
                self._log_change("Estructura", "div role=main", "main", 0)

        self._apply_regex(r'<' + r'/div>(\s*(?:<!--[\s\S]*?-->\s*)*<footer)', r'\1', "Estructura: Eliminar div cierre huérfano antes de footer")
        self._apply_regex(r'</p>Esta página', '<p>Esta página', "HTML: p invertido")
        self._apply_regex(r'<p>(.*?)<p>', r'<p>\1</p>', "HTML: p mal cerrado")
        self._apply_regex(r'<span>([^<]+)(?!\s*</span>)', r'<span>\1</span>', "HTML: span abierto")
        self._apply_regex(r'<br\s+/>', '<br>', "HTML: XHTML br a HTML5")
        self._apply_regex(r'id="titulo-estructuraa"', 'id="titulo-estructura"', "HTML: Typo ID estructura")
        self._apply_regex(r'<section id="diseno-web" aria-labelledby="titulo-diseno-web2">', '<section id="diseno-web-dup" aria-labelledby="titulo-diseno-web2">', "HTML: ID duplicado específico")
        
        block_tags = r'(?:div|p|h[1-6]|ul|ol|table|form|blockquote|pre|address|main|header|footer|nav|section|article|aside|hr)'
        self._apply_regex(rf'(<p[^>]*>)((?:(?!</p>).)*?)(?=\s*<(?:{block_tags})\b)', r'\1\2</p>', "Estructura: Cierre defensivo de p antes de bloque")

        self._apply_regex(r'(<(?:ul|ol)[^>]*>)\s*(<(?:ul|ol)[^>]*>)', r'\1<li>\2', "Estructura: Listas anidadas wrapper li")
        self._apply_regex(r'<li>(.*?)(?=\n\s*<li>|\n\s*</ul>)', r'<li>\1</li>', "HTML: li cierre automático")
        
        self._apply_regex(r'<b>(.*?)</b>', r'<strong>\1</strong>', "Semántica: b a strong")
        self._apply_regex(r'<i>(.*?)</i>', r'<em>\1</em>', "Semántica: i a em")
        self._apply_regex(r'<center>(.*?)</center>', r'<div style="text-align:center">\1</div>', "W3C: Deprecado center")
        self._apply_regex(r'<font[^>]*>(.*?)</font>', r'<span>\1</span>', "W3C: Deprecado font")
        self._apply_regex(r'<strike>(.*?)</strike>', r'<del>\1</del>', "Semántica: strike a del")
        self._apply_regex(r'<u>(.*?)</u>', r'<span style="text-decoration: underline;">\1</span>', "A11y: u confuso")

        self._apply_regex(r'(<table[^>]*)border=["\']\d+["\']', r'\1', "Clean: Tabla border")
        self._apply_regex(r'(<[^>]+)align=["\'][^"\']*["\']', r'\1', "Clean: Atributo align")
        self._apply_regex(r'(<[^>]+)bgcolor=["\'][^"\']*["\']', r'\1', "Clean: Atributo bgcolor")
        self._apply_regex(r'<td\s+headers=["\'][^"\']*["\']', '<td', "Clean: Headers complejos en TD")
        self._apply_regex(r'<table[^>]*\bsummary=["\'][^"\']*["\']', '<table', "W3C: Summary obsoleto")

    def _fix_roles_and_aria(self):
        redundant_roles = [
            (r'role="banner"\s+role="header"', 'role="banner"'),
            (r'role="navigation main"', 'role="navigation"'),
            (r'<nav[^>]*role=["\']navigation["\']', '<nav'),
            (r'<header[^>]*role=["\']banner["\']', '<header'),
            (r'<footer[^>]*role=["\']contentinfo["\']', '<footer'),
            (r'<main[^>]*role=["\']main["\']', '<main'),
            (r'<form[^>]*role=["\']form["\']', '<form'),
        ]
        for pat, rep in redundant_roles:
            self._apply_regex(pat, rep, "ARIA: Roles redundantes")

        self._apply_regex(r'aria-role=["\']link["\']', 'role="link"', "ARIA: aria-role no existe")
        self._apply_regex(r'role=["\']menuu["\']', 'role="menu"', "ARIA: Typo menuu")
        self._apply_regex(r'role=["\']menubar["\']', 'role="menu"', "ARIA: Simplificar menubar")
        self._apply_regex(r'role=["\']menuitemcheckbox["\']', 'role="menuitem"', "ARIA: Simplificar checkbox")
        
        self._apply_regex(r'aria-haspopup=["\']menuu["\']', 'aria-haspopup="true"', "ARIA: Valor menuu incorrecto")
        self._apply_regex(r'aria-expanded=["\']falso["\']', 'aria-expanded="false"', "ARIA: Valor falso incorrecto")
        self._apply_regex(r'aria-pressed=["\']talvez["\']', 'aria-pressed="false"', "ARIA: Valor talvez incorrecto")
        self._apply_regex(r'aria-hidden=["\']talvez["\']', 'aria-hidden="true"', "ARIA: Valor talvez incorrecto")
        self._apply_regex(r'aria-hidden=["\']false["\']', '', "ARIA: Default false limpieza")
        self._apply_regex(r'aria-labelled-by=', 'aria-labelledby=', "ARIA: Typo labelledby")
        self._apply_regex(r'aria-label=""', 'aria-label="Acción"', "ARIA: Label vacío relleno")

    def _fix_forms_and_attributes(self):
        self._apply_regex(r'type=["\']submit["\']', 'type="button"', "Form: submit a button genérico")
        self._apply_regex(r'data-menu-button=["\']true["\']', 'data-menu-button', "HTML: Boolean attribute normalización")
        self._apply_regex(r'hidden=["\']hidden["\']', 'hidden', "HTML: Hidden normalización")
        
        self._apply_regex(r'(<input(?![^>]*aria-label)(?![^>]*type=["\'](?:hidden|submit|button|image)["\'])[^>]*placeholder=["\']([^"\']+)["\'][^>]*)>', r'\1 aria-label="\2">', "A11y: Placeholder a label")
        self._apply_regex(r'(<input[^>]*type=["\']email["\'])(?![^>]*autocomplete)', r'\1 autocomplete="email"', "Form: Autocomplete Email")
        self._apply_regex(r'(<input[^>]*type=["\']tel["\'])(?![^>]*autocomplete)', r'\1 autocomplete="tel"', "Form: Autocomplete Tel")
        
        self._apply_regex(r'autofocus(?:=["\']autofocus["\'])?', '', "A11y: Eliminar autofocus")
        self._apply_regex(r'accesskey=["\'][^"\']*["\']', '', "A11y: Eliminar accesskey")
        self._apply_regex(r'tabindex=["\'][1-9]\d*["\']', 'tabindex="0"', "A11y: Tabindex positivo a 0")
        
        self._apply_regex(r'<button((?![^>]*type=)[^>]*)>', r'<button type="button"\1>', "Form: Button type explícito")
        self._apply_regex(r'<input\s+type=["\']submit["\']', '<button type="submit"', "Form: Input Submit a Button")

    def _fix_links_images_cleanups(self):
        self._apply_regex(r'href="(?!http|#|mailto:)([a-zA-Z0-9-]+)"', r'href="#\1"', "Nav: Link interno fix")
        self._apply_regex(r'href="#contenido-principal\s+noexistente"', 'href="#contenido-principal"', "Nav: Skip link fix")
        self._apply_regex(r'href=["\']mail:\s*', 'href="mailto:', "Link: Protocolo mail fix")
        self._apply_regex(r'href=["\']tel:\s*', 'href="tel:', "Link: Protocolo tel fix")
        self._apply_regex(r'(<a[^>]*target=["\']_blank["\'])(?![^>]*rel)', r'\1 rel="noopener noreferrer"', "Sec: Target blank seguro")
        self._apply_regex(r'<a[^>]*href=["\'](?:#|javascript:void\(0\);?)["\'][^>]*>\s*</a>', '', "Limpieza: Link vacío")
        
        self._apply_regex(r'menu\.hidden\s*=\s*"false"', 'menu.hidden = false', "JS: String bool fix")
        self._apply_regex(r'\?\s*closeMenu\s*:\s*openMenu', '? closeMenu() : openMenu()', "JS: Ternario call fix")
        self._apply_regex(r'firstLink\.focus\(\)', 'if (firstLink) firstLink.focus()', "JS: Null check focus")
        
        self._apply_regex(r'los-menues-debens-ser-accesibles="sí"', '', "Limpieza: Atributo basura")
        self._apply_regex(r'alt="Texto que no se usa en enlaces"', '', "HTML: Alt en enlace borrado")
        self._apply_regex(r'<a>Consultoría', '<a href="#">Consultoría', "HTML: Link roto fix")
        
        self._apply_regex(r'\.jgp["\']', '.jpg"', "Typo: Extensión jgp")
        self._apply_regex(r'\.pnj["\']', '.png"', "Typo: Extensión pnj")
        self._apply_regex(r'(<img(?![^>]*alt=)[^>]*)(>)', r'\1 alt=""\2', "A11y: Alt vacío preventivo")
        self._apply_regex(r'<img src="banner.png"(?: alt=".*?")?>', '<img src="banner.png" alt="Banner promocional genérico">', "A11y: Alt específico banner")
        self._apply_regex(r'(<img[^>]*)\stitle=["\'][^"\']*["\']', r'\1', "A11y: Eliminar title redundante en img")

        typos = {
            r'cllas=': 'class=', r'srcrn=': 'src=', r'hfre=': 'href=',
            r'witdh=': 'width=', r'heigth=': 'height=', r'tab-index=': 'tabindex=',
            r'col-span=': 'colspan=', r'row-span=': 'rowspan=', r'readonly=': 'readonly'
        }
        for bad, good in typos.items():
            self._apply_regex(bad, good, f"Typo: {bad}")

        self._apply_regex(r'\son[a-z]+=["\']return\s+false;?["\']', '', "JS: Eliminar return false inline")
        self._apply_regex(r'\slanguage=["\']javascript["\']', '', "W3C: Script language obsoleto")

    def _scan_manual_checks(self):
        html = self.current_html.lower()
        checks = [
            ("<script", "ALTA", "Javascript", "Verificar Focus Trap, gestión de estado y eventos teclado."),
            ("onclick", "ALTA", "Eventos", "Asegurar paridad teclado (onkeydown/click)."),
            ("onmouseover", "MEDIA", "Eventos", "Asegurar paridad teclado (onfocus)."),
            ("tabindex", "MEDIA", "Tabindex", "Verificar flujo lógico (evitar saltos)."),
            ("<iframe", "MEDIA", "Contenido", "Verificar atributo title descriptivo."),
            ("<video", "MEDIA", "Multimedia", "Verificar captions/subtítulos."),
            ("<audio", "MEDIA", "Multimedia", "Verificar transcripción."),
            ("autoplay", "ALTA", "Intrusivo", "Eliminar reproducción automática."),
            ("justify", "BAJA", "Legibilidad", "Texto justificado daña lectura en dislexia."),
            ("click here", "MEDIA", "Semántica", "Enlace vago ('click aquí'). Usar descriptivos."),
            ("leer más", "MEDIA", "Semántica", "Enlace vago ('leer más'). Usar descriptivos."),
            ("marquee", "ALTA", "Obsolescencia", "Elemento marquee debe eliminarse."),
            ("blink", "ALTA", "Obsolescencia", "Elemento blink debe eliminarse."),
            ("user-scalable=no", "ALTA", "Zoom", "Bloqueo de zoom detectado."),
            ("skip-link", "MEDIA", "Navegación", "Verificar visibilidad CSS al recibir foco."),
            ("color:", "ALTA", "Contraste", "Verificar ratio contraste manual 4.5:1."),
            ("background", "ALTA", "Contraste", "Verificar ratio contraste manual 4.5:1."),
        ]
        
        for token, prio, cat, msg in checks:
            if token in html:
                self.manual_warnings.append({"prioridad": prio, "categoria": cat, "mensaje": msg})

        if html.count("<h1") > 1:
            self.manual_warnings.append({"prioridad": "MEDIA", "categoria": "Estructura", "mensaje": "Múltiples H1 detectados."})
        
        if "<img" in html and "alt" in html:
             self.manual_warnings.append({"prioridad": "ALTA", "categoria": "Semántica", "mensaje": "Verificar calidad descriptiva de textos alternativos."})

    def run(self) -> Tuple[str, List[Dict[str, Any]], List[Dict[str, Any]]]:
        self._fix_head_metadata()
        self._fix_css_and_styles()
        self._fix_structure_and_semantics()
        self._fix_roles_and_aria()
        self._fix_forms_and_attributes()
        self._fix_links_images_cleanups()
        self._scan_manual_checks()
        return self.current_html, self.changes, self.manual_warnings

if __name__ == "__main__":
    html_test = """
    <html lang="es" lang="en">
    <head><meta http-equiv="Content-Type" content="text/html; charset=utf-88"><title></title></head>
    <body>
        <center><b>Título Antiguo</b></center>
        <div role="main" id="contenido">
            <p>Texto sin cerrar <br />
            <ul><ul><li>Item</li></ul></ul>
            <input type="email" placeholder="Correo" los-menues-debens-ser-accesibles="sí">
            <a href="mail:test@test.com" target="_blank">Escríbeme</a>
            <img src="test.pnj" title="foto">
            <font size="3">Texto viejo</font>
            <div role="navigation main">Nav</div>
            <a href="#" class="skip-link">Saltar</a>
        </div>
    </body></html>
    """
    fixer = AutoFixer(html_test)
    final_html, changes, warnings = fixer.run()
    
    import json
    print("--- HTML FINAL ---")
    print(final_html)
    print("\n--- CAMBIOS ---")
    print(json.dumps(changes, indent=2))
    print("\n--- MANUAL ---")
    print(json.dumps(warnings, indent=2))